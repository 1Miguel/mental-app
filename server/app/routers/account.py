"""Account management.

Contains all routes and routines that manages all account related services.

date: 02/11/2023
"""
import logging
from pathlib import Path
from tempfile import TemporaryDirectory
from datetime import datetime
from typing import Any, Optional

# third-party imports
import jwt
from passlib.hash import bcrypt
from fastapi import HTTPException, Response, status, Depends, APIRouter
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from tortoise.exceptions import DoesNotExist, IntegrityError
from tortoise.contrib.pydantic import pydantic_model_creator

# internal modules
from internal.database import *
from internal.schema import *

# ------------------------------------------------------ #
# Debug
# ------------------------------------------------------ #
# logger module
log = logging.getLogger(__name__)

# ------------------------------------------------------ #
# Globals
# ------------------------------------------------------ #
# secret code, this is random and autogenerated
_JWT_SECRET = "v7hPzbPawtFcszHA4n9d"
# user(pydantic dataclass) schema from usermodel
UserSchema = pydantic_model_creator(UserModel, name="User", exclude_readonly=False)
# oauth authentication scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


async def get_current_user(token: str = Depends(oauth2_scheme)) -> UserModel:
    """Returns the user database model from given token. This is the validation
    routine when a user attempts to access a page that requries authentication
    via token.

    Args:
        token (str, optional): User Token. Defaults to Depends(oauth2_scheme).

    Raises:
        HTTPException: HTTP_401_UNAUTHORIZED for invalid access.
    """
    try:
        # ---- check if this email has valid auth
        user: UserModel = await UserModel.get(
            email=jwt.decode(token, _JWT_SECRET, algorithms="HS256").get("email")
        )
    except:
        # ---- account invalid or user does not exist
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
        )
    # ---- check if this account is an admin
    is_admin = await AdminModel.exists(admin_user=user)

    # ---- return account json profile
    # TODO: should I just return the actual database item?
    return UserProfileApi(
        id=user.id,
        email=user.email,
        firstname=user.firstname,
        lastname=user.lastname,
        address=user.address,
        age=user.age,
        occupation=user.occupation,
        birthday=user.birthday,
        is_admin=is_admin,
    )


class AccountManager:
    # temporary file where all files will be stored
    _temp_file_storage: TemporaryDirectory = "./files"

    def __init__(self, router: Optional[APIRouter] = None) -> None:
        self._routing = router if router else APIRouter()
        #: ---- Set all routes
        self._routing.add_api_route(
            "/login", self.login, methods=["POST"], response_model=UserProfileApi
        )
        self._routing.add_api_route(
            "/signup",
            self.signup,
            methods=["POST"],
        )
        self._routing.add_api_route(
            "/token", self._generate_token, methods=["POST"], response_model=Any
        )

    @property
    def router(self) -> APIRouter:
        """FastAPI Router Instance.

        Returns:
            APIRouter: This class api router.
        """
        return self._routing

    async def _get_authenticated_user(self, email: str, password: str) -> UserModel:
        """Returns the authenticated user database model if the given
        credentials are correct, else this will return None.
        """
        user = await UserModel.get(email=email)
        if not user:
            return None
        if not user.verify_password(password):
            return None
        return user

    async def _generate_token(
        self, form_data: OAuth2PasswordRequestForm = Depends(), response: Response = Response()
    ) -> Any:
        """Generates a session token."""
        try:
            user_model = await self._get_authenticated_user(form_data.username, form_data.password)
        except DoesNotExist:
            response.status_code = status.HTTP_401_UNAUTHORIZED
            return {"error": f"account does not exist"}
        else:
            if user_model:
                user = await UserSchema.from_tortoise_orm(user_model)
                token = jwt.encode(user.model_dump(), _JWT_SECRET)
                return {"access_token": token, "token_type": "bearer"}
            else:
                response.status_code = status.HTTP_401_UNAUTHORIZED
                return {"error": "invalid credentials"}

    async def login(self, user: UserProfileApi = Depends(get_current_user)) -> UserProfileApi:
        """login route called when user wants to login. This depends on the user
        if the user has a token. If the user does not have a valid token, reject
        the login request.
        """
        # return the profile at login success
        return user

    async def signup(self, user: UserSignUpApi) -> None:
        """Route to call when user wishes to create a new account.
        This requires unique credential. if email or email is already used,
        reject the signup request.
        """
        log.info("Create user %s", user)
        try:
            user: UserModel = UserModel(
                email=user.email,
                password_hash=bcrypt.hash(user.password),
                firstname=user.firstname,
                lastname=user.lastname,
                address="",
                age=0,
                occupation="",
                birthday=datetime(year=1900, month=1, day=1).isoformat(),
            )
            await user.save()
            # create a folder space for the user, this will serve as
            # file storage path where all files user uploads will be stored.
            Path(self._temp_file_storage.name).joinpath(str(user.id)).mkdir(exist_ok=True)

        except IntegrityError as err:
            log.critical("Attempt to create user that already exist.")
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT, detail="email is already used."
            ) from err
