import sys
import logging
import datetime
from typing import Dict, Any, Optional

# third-party imports
import jwt
from passlib.hash import bcrypt
from fastapi import FastAPI, HTTPException, Response, status, Depends
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from tortoise.exceptions import DoesNotExist, IntegrityError
from tortoise.contrib.fastapi import register_tortoise
from tortoise.contrib.pydantic import pydantic_model_creator

# internal modules
from internal.database import UserModel, MoodModel, MoodId
from internal.schema import MoodLog, UserApi

# logger module
log = logging.getLogger(__name__)
# TODO: Add a flag if logging must be displayed in the terminal
#       flag can either be an env variable or from a file.
#       another option is for this to be in the unit test file.
log.setLevel(logging.DEBUG)
handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logging.DEBUG)
handler.setFormatter(logging.Formatter("%(levelname)s: %(asctime)-15s : %(message)s"))
log.addHandler(handler)

# main application instance
app = FastAPI()

# secret code, this is random and autogenerated
_JWT_SECRET = "v7hPzbPawtFcszHA4n9d"

# connect to the database
# create a database if does not exist
register_tortoise(
    app,
    db_url="sqlite://db.sqlite3",
    modules={"models": ["internal.database"]},
    generate_schemas=True,
)

# user(pydantic dataclass) schema from usermodel
UserSchema = pydantic_model_creator(UserModel, name="User", exclude_readonly=False)
UserSchemaReadOnly = pydantic_model_creator(
    UserModel, name="User", exclude_readonly=True
)
# oauth authentication scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


@app.get("/")
def index() -> Dict[str, str]:
    return {"message": "Hello World"}


async def get_authenticated_user(email: str, password: str) -> UserModel:
    user = await UserModel.get(email=email)
    if not user:
        return None
    if not user.verify_password(password):
        return None
    return user


async def get_current_user(token: str = Depends(oauth2_scheme)):
    # as long as there is an oauth2 scheme in the
    # dependency chain, that would be locked in
    # to the login user dependency
    log.info("get current user with token %s", token)
    try:
        payload = jwt.decode(token, _JWT_SECRET, algorithms="HS256")
        user = await UserModel.get(email=payload.get("email"))
    except:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
        )
    return await UserSchema.from_tortoise_orm(user)


@app.post("/token", status_code=status.HTTP_200_OK)
async def generate_token(
    form_data: OAuth2PasswordRequestForm = Depends(), response: Response = Response()
):
    """Generates a session token."""
    try:
        user_model = await get_authenticated_user(
            form_data.username, form_data.password
        )
    except DoesNotExist:
        response.status_code = status.HTTP_401_UNAUTHORIZED
        return {"error": f"account does not exist"}
    else:
        if user_model:
            user = await UserSchema.from_tortoise_orm(user_model)
            token = jwt.encode(user.model_dump(), _JWT_SECRET)
            return {"access_token": token, "token_type": "bearer"}
        else:
            response.status_code = status.HTTP_401_UNAUTHORIZED
            return {"error": "invalid credentials"}


@app.get("/login", response_model=UserSchema)
def login(user: UserSchema = Depends(get_current_user)) -> Any:
    """login route called when user wants to login. This depends on the user
    if the user has a token. If the user does not have a valid token, reject
    the login request.
    """
    log.info("logging in...")
    return user


@app.get("/users/mood", response_model=UserSchema)
async def mood_log(
    user: UserSchema = Depends(get_current_user), mood: Optional[MoodLog] = None
):
    """Daily Mood Logging."""
    if mood is None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid Data."
        )
    today = datetime.datetime.today().date()
    if MoodModel.get(date=today):
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT, detail="Mood already set for today."
        )
    log.debug("Create new mood for %s", user)
    # log new mood today
    new_mood = MoodModel(user=user, mood=MoodId(mood.mood), date=today)
    await new_mood.save()
    return await UserSchema.from_tortoise_orm(user)


@app.post("/signup", response_model=UserSchema)
async def users(user: UserApi) -> Any:
    """Route to call when user wishes to create a new account.
    This requires unique credential. if email or email is already used,
    reject the signup request.
    """
    log.info("Create user %s", user)

    try:
        user = UserModel(
            email=user.email,
            password_hash=bcrypt.hash(user.password_hash),
            firstname=user.firstname,
            lastname=user.lastname,
            address=user.address,
            age=user.age,
            occupation=user.occupation,
        )
        await user.save()
    except IntegrityError as err:
        log.critical("Attempt to create user that already exist.")
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT, detail="email is already used."
        ) from err
    else:
        return await UserSchema.from_tortoise_orm(user)

def main() -> None:
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)

if __name__ == "__main__":
    main()
