import sys
import logging
from datetime import datetime
from typing import Dict, Any, Optional

# third-party imports
import jwt
from passlib.hash import bcrypt
from fastapi import FastAPI, HTTPException, Response, status, Depends
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from tortoise.exceptions import DoesNotExist, IntegrityError
from tortoise.contrib.fastapi import register_tortoise
from tortoise.contrib.pydantic import pydantic_model_creator
from fastapi.middleware.cors import CORSMiddleware

# internal modules
from internal.database import *
from internal.schema import *

# logger module
log = logging.getLogger(__name__)
# TODO: Add a flag if logging must be displayed in the terminal
#       flag can either be an env variable or from a file.
#       another option is for this to be in the unit test file.
log.setLevel(logging.DEBUG)
handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logging.DEBUG)
handler.setFormatter(logging.Formatter("%(levelname)s: %(asctime)-15s : %(message)s"))
log.addHandler(handler)

# main application instance
app = FastAPI()

origins = ["*"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# secret code, this is random and autogenerated
_JWT_SECRET = "v7hPzbPawtFcszHA4n9d"

# connect to the database
# create a database if does not exist
register_tortoise(
    app,
    db_url="sqlite://db.sqlite3",
    modules={"models": ["internal.database"]},
    generate_schemas=True,
)

# user(pydantic dataclass) schema from usermodel
UserSchema = pydantic_model_creator(UserModel, name="User", exclude_readonly=False)
UserSchemaReadOnly = pydantic_model_creator(UserModel, name="User", exclude_readonly=True)
# oauth authentication scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


@app.on_event("startup")
async def startup() -> None:
    """Routine at application startup."""
    log.info("Startup routine")


@app.get("/")
def index() -> Dict[str, str]:
    """Index route.
    TODO: Implement the right routine"""
    return {"message": "Hello World"}


async def get_authenticated_user(email: str, password: str) -> UserModel:
    """Returns the authenticated user database model if the given
    credentials are correct, else this will return None.
    """
    user = await UserModel.get(email=email)
    if not user:
        return None
    if not user.verify_password(password):
        return None
    return user


async def get_current_user(token: str = Depends(oauth2_scheme)):
    # as long as there is an oauth2 scheme in the
    # dependency chain, that would be locked in
    # to the login user dependency
    try:
        payload = jwt.decode(token, _JWT_SECRET, algorithms="HS256")
        user = await UserModel.get(email=payload.get("email"))
    except:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
        )
    return await UserSchema.from_tortoise_orm(user)


@app.post("/token", status_code=status.HTTP_200_OK)
async def generate_token(
    form_data: OAuth2PasswordRequestForm = Depends(), response: Response = Response()
) -> Any:
    """Generates a session token."""
    try:
        user_model = await get_authenticated_user(form_data.username, form_data.password)
    except DoesNotExist:
        response.status_code = status.HTTP_401_UNAUTHORIZED
        return {"error": f"account does not exist"}
    else:
        if user_model:
            user = await UserSchema.from_tortoise_orm(user_model)
            token = jwt.encode(user.model_dump(), _JWT_SECRET)
            return {"access_token": token, "token_type": "bearer"}
        else:
            response.status_code = status.HTTP_401_UNAUTHORIZED
            return {"error": "invalid credentials"}


@app.get("/login", response_model=UserProfileApi)
async def login(user: UserSchema = Depends(get_current_user)) -> Any:
    """login route called when user wants to login. This depends on the user
    if the user has a token. If the user does not have a valid token, reject
    the login request.
    """
    # return the profile at login success
    return UserProfileApi(
        id=user.id,
        email=user.email,
        firstname=user.firstname,
        lastname=user.lastname,
        address=user.address,
        age=user.age,
        occupation=user.occupation,
        birthday=user.birthday,
        membership_type=MembershipType.NONE,
    )


@app.post("/user/mood")
async def mood_log(mood: MoodLog, user: UserSchema = Depends(get_current_user)) -> None:
    """Daily Mood Logging. if mood score has been log for today, dont lot anymore
    and return an HTTP_409_CONFLICT error."""
    user = await UserModel.get(email=user.email)
    today = datetime.today().date()
    try:
        mood_id = MoodId(mood.mood)
        mood_db = await MoodModel.get(date=datetime.today().date())
        mood_db.mood = mood_id
        mood_db.note = mood.note
    except DoesNotExist:  # no data log today, create a new data to save
        mood_db = MoodModel(user=user, mood=mood_id, date=today, note=mood.note)
    except ValueError:  # invalid mood id
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid Data.")
    await mood_db.save()


@app.get("/user/mood/", response_model=MoodListResponse)
async def mood_get(month: str, user: UserSchema = Depends(get_current_user)) -> MoodListResponse:
    """This handles the mood log request. This will return a response that contains
    list of all moods log in a given month."""
    try:
        month = datetime.fromisoformat(month)
        response = MoodListResponse(mood_list=[])
        for mood_db_data in await MoodModel.get_all_by_month(user.email, month):
            response.mood_list += [
                MoodLog(
                    mood=mood_db_data.id, note=mood_db_data.note, date=mood_db_data.date.isoformat()
                )
            ]
        return response
    except ValueError as exc:  # wrong datetime isoformat
        log.error("Receive Invalid Month %s", month)
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=f"given month {month} is not a valid isoformat",
        ) from exc


@app.post("/signup")
async def signup_route(user: UserApi) -> Any:
    """Route to call when user wishes to create a new account.
    This requires unique credential. if email or email is already used,
    reject the signup request.
    """
    log.info("Create user %s", user)
    try:
        user = UserModel(
            email=user.email,
            password_hash=bcrypt.hash(user.password),
            firstname=user.firstname,
            lastname=user.lastname,
            address="",
            age=0,
            occupation="",
            birthday=datetime(year=1900, month=1, day=1).isoformat(),
        )
        await user.save()
    except IntegrityError as err:
        log.critical("Attempt to create user that already exist.")
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT, detail="email is already used."
        ) from err


def run() -> None:
    import uvicorn

    uvicorn.run(app, host="127.0.0.1", port=8000)


if __name__ == "__main__":
    run()
